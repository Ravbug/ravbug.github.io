<head>
    <title>
        The Beginning
     </title>
     <meta name="description" content="RavEngine Development Blog">
     <link id="favicon" rel="icon" href="../../../ravbug.png">
 
     <meta property="og:image" content="https://www.ravbug.com/ravbug.png">
     <meta property="og:image:type" content="image/png">
     <meta property="og:image:width" content="512">
     <meta property="og:image:height" content="512">
     <meta charset="utf-8">
     <link rel="stylesheet" href="../../blog.css">
     {HEADER_CONTENT}
</head>
{JUMBOTRON}
<div class="main split">
<div>
<h2>1: Writing a game engine, without writing a game engine</h2>
<script src="../date.js" date="6/9/2020"></script>

<p>
    I've been writing software since 2010, and have always been fascinated with game development. 
    I got into the game development space in 2015, using engines like Unreal, Unity, and Godot. 
</p>
<p>
    While each of these engines are extremely powerful and in dedicated hands will produce stunning results, I could never get into any of them.
</p>
<ul>
    <li>Unreal
        <ul>
            <li>
                Designed for Triple-A titles, so requires a lot of disk space (20+ GB!) and a powerful PC to run the editor
            </li>
            <li>
                C++ documentation is poor to non-existent, and C++ API is not intuitive
            </li>
            <li>
                Poor performance on mobile or low end PCs, especially compared to Unity and Godot
            </li>
            <li>
                Lots of bugs in C++/blueprint interop leading to blueprint corruption
            </li>
            <li>
                C++ incremental compile times are very slow
            </li>
            <li>
                Lack of community-made resources and tutorials, compared to Unity and Godot
            </li>
        </ul>
    </li>
    <li>
        Unity
        <ul>
            <li>
                Editor is buggy and unresponsive
            </li>
            <li>
                Slow asset importing times
            </li>
            <li>
                No built-in networking workflow. You must create symlinks of your project to trick the editor into opening the project twice, or 
                create builds every time you need to test a change.
            </li>
            <li>
                High percentage of broken or rushed updates with regressions, compared to Unreal or Godot
            </li>
            <li>
                Features ship incomplete with no guarantee of future progress (RIP UNET)
            </li>
        </ul>
       
    </li>
    <li>
        Godot
        <ul>
            <li>
                Does not scale upwards
            </li>
            <li>
                Requires a custom slow programming language, bindings to other languages have poor documentation and/or are incomplete
            </li>
            <li>
                Features behave in unexpected or incorrect ways, especially physics
            </li>
        </ul>
    </li>
</ul>

<p>
    As COVID-19 hit and my second semester at the University of Michigan finished, I found myself in need of a summer project. I decided that I would write my own game engine.
</p>
<p>
    I have a few major goals for my engine:
    <ol>
        <li>
            Cross-platform, native, on mobile and desktop
        </li>
        <li>
            Free automatic multi-threading via an Entity-Component-System model, while also supporting OOP
        </li>
        <li>
            Offer a clean, well-documented, and easy to use Modern C++ API
        </li>
        <li>
            Provide automatic memory management through reference counting instead of a garbage collector, to provide control over memory without risking leaks
        </li>
        <li>
            Support modern rendering backends, like Metal, Vulkan, and DirectX
        </li>
    </ol>
</p>
<p>
    There's one problem with that idea: writing your own game engine from the ground up is a colossal waste of time, and with these goals, I would have no hope of finishing. 
    I know that I cannot replicate the work of hundreds of talented, experienced developers, by myself. 
    So instead, I decided to find out if I could write a game engine, without <i>writing</i> a game engine. I added two more goals:

    <ul>
        <li>
            Leverage existing technology wherever possible
        </li>
        <li>
            No GUI
        </li>
    </ul>
    In essence: Don't reinvent the wheel (at least, not more than I already am by writing a game engine). The second one may seem a little odd though - how is no GUI better? 
    It offers a few advantages: the complexity of creating a good UI is gone, and an engine GUI is often not necessary for the vast majority of engine tasks. Rather than design
    my own workflow, I can design my engine as a library and leverage existing creation tools.
</p>
<p>
    This brings me to my first rule: always plan before you program!
    I plan out everything ahead of time on a simple text document, from what the code will do to how the API will look. This saves a lot
    of time, because iterating on paper is cheap. I've spent far less time rewriting code after adopting this strategy.
</p>
<p>
    Next Up: <a href="../memory-management/">Memory Management via Automatic Reference Counting</a>
</p>
</div>
<div>
    <script src="../../table-contents.js"></script>
    <script src="../display.js" pathroot=".."></script>
</div>
</div>
<script src="../../../statistics.js" url="https://bit.ly/3dsG1Fo"></script>  